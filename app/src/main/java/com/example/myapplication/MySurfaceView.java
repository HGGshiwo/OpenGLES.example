package com.example.myapplication;//声明包
import java.io.IOException;
import java.io.InputStream;

import android.opengl.GLSurfaceView;
import android.opengl.GLES30;
import android.opengl.GLUtils;
import android.opengl.Matrix;
import android.view.MotionEvent;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.view.View;
import android.widget.Button;
import android.widget.SeekBar;

import androidx.cardview.widget.CardView;

import com.example.myapplication.Camera.Camera;
import com.example.myapplication.Camera.Light;
import com.example.myapplication.Object.Model;
import com.example.myapplication.Shader.Shader;

class MySurfaceView extends GLSurfaceView 
{
	private final float TOUCH_SCALE_FACTOR = 180.0f/320;//角度缩放比例
    private SceneRenderer mRenderer;//场景渲染器    
    
    private float mPreviousY;//上次的触控位置Y坐标
    private float mPreviousX;//上次的触控位置X坐标
    
    private Shader shader;
    private Model model;
    private Camera camera;
    private Light light;

	public MySurfaceView(Context context) {
        super(context);
        this.setEGLContextClientVersion(3); //设置使用OPENGL ES3.0
        mRenderer = new SceneRenderer();	//创建场景渲染器
        setRenderer(mRenderer);				//设置渲染器		        
        setRenderMode(GLSurfaceView.RENDERMODE_CONTINUOUSLY);//设置渲染模式为主动渲染
	}
	
	//触摸事件回调方法
    @Override 
    public boolean onTouchEvent(MotionEvent e)
    {
        float y = e.getY();
        float x = e.getX();
        switch (e.getAction()) {
        case MotionEvent.ACTION_MOVE:
            float dy = y - mPreviousY;//计算触控笔Y位移
            float dx = x - mPreviousX;//计算触控笔X位移
            mRenderer.yAngle += dx * TOUCH_SCALE_FACTOR;//设置沿y轴旋转角度
            mRenderer.xAngle+= dy * TOUCH_SCALE_FACTOR;//设置沿x轴旋转角度
            requestRender();//重绘画面
        }
        mPreviousY = y;//记录触控笔位置
        mPreviousX = x;//记录触控笔位置
        return true;
    }

    public void moveObjectLeft(){
	    model.translate(-1,0,0);
    }

    public void moveObjectRight(){
        model.translate(1,0,0);
    }

    public void moveObjectUp(){
        model.translate(0,1,0);
    }

    public void moveObjectDown(){
        model.translate(0,-1,0);
    }

    public void moveCameraLeft(){
	    camera.translate(-0.1f, 0,0);
    }

    public void moveCameraRight(){
	    camera.translate(0.1f, 0, 0);
    }

    public void moveCameraUp(){
	    camera.translate(0,0.1f,0);
    }

    public void moveCameraDown(){
	    camera.translate(0,-0.1f,0);
    }

	private class SceneRenderer implements GLSurfaceView.Renderer
    {
		float yAngle;//绕Y轴旋转的角度
    	float xAngle; //绕X轴旋转的角度

        public void onSurfaceCreated(GL10 gl, EGLConfig config) {
            //设置屏幕背景色RGBA
            GLES30.glClearColor(0.0f,0.0f,1.0f,1.0f);
            //打开深度检测
            GLES30.glEnable(GLES30.GL_DEPTH_TEST);
            //打开背面剪裁
            GLES30.glEnable(GLES30.GL_CULL_FACE);
            //加载着色器
            shader = new Shader("vertex.sh","frag.sh", getResources());
            //加载要绘制的物体
            model = new Model("ch_t.obj", R.drawable.qhc, MySurfaceView.this.getResources());
            model.translate(0, -16f, -60f);
            //设置照相机
            camera = new Camera(-1, 1, -1, 1, 2, 100,
                    0,0,0,0f,0f,-1f,0f);
            //初始化光源位置
            light = new Light("uLightLocation",-1, 1, -1, 1, 2, 100,
                    40,10,20,0f,0f,-1f,0f);
        }

        public void onDrawFrame(GL10 gl) 
        { 
        	//清除深度缓冲与颜色缓冲
            GLES30.glClear(GLES30.GL_DEPTH_BUFFER_BIT | GLES30.GL_COLOR_BUFFER_BIT);

//            //坐标系推远
//            model.translate(0, -16f, -60f);
//
//            //绕Y轴、X轴旋转
//            model.rotate(yAngle, 0, 1, 0);
//            model.rotate(xAngle, 1, 0, 0);

            //指定使用某套着色器程序
            shader.use();
            //将最终变换矩阵传入着色器程序
            float[] mMVPMatrix=new float[16];
            Matrix.multiplyMM(mMVPMatrix, 0, camera.mVMatrix, 0, model.currMatrix, 0);
            Matrix.multiplyMM(mMVPMatrix, 0, camera.mProjMatrix, 0, mMVPMatrix, 0);
            shader.setMat4f("uMVPMatrix", mMVPMatrix);
            //将位置、旋转变换矩阵传入着色器程序
            shader.setMat4f("uMMatrix", model.currMatrix);
            // 将顶点位置数据传入渲染管线
            shader.setPointer3f("aPosition",false, model.mVertexBuffer);
            //将顶点法向量数据传入渲染管线
            shader.setPointer3f("aNormal",false, model.mNormalBuffer);
            //将顶点纹理坐标数据传入渲染管线
            shader.setPointer2f("aTexCoor", false, model.mTexCoorBuffer);
            //将摄像机位置传入着色器程序
            shader.setVec3f("uCamera", camera.cameraFB);
            //将光源位置传入着色器程序
            shader.setVec3f("uLightLocation", light.cameraFB);
            model.draw();
        }  

        public void onSurfaceChanged(GL10 gl, int width, int height) {
            //设置视窗大小及位置 
        	GLES30.glViewport(0, 0, width, height); 
        	//计算GLSurfaceView的宽高比
            float ratio = (float) width / height;
            //调用此方法计算产生透视投影矩阵
            camera.setProjectFrustum(-ratio, ratio, -1, 1, 2, 100);
        }
    }


}
